\documentclass[a4paper]{book}

\usepackage{geometry}
% make full use of A4 papers
\geometry{margin=1.5cm, vmargin={0pt,1cm}}
\setlength{\topmargin}{-1cm}
\setlength{\paperheight}{29.7cm}
\setlength{\textheight}{25.1cm}

% auto adjust the marginals
\usepackage{marginfix}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{CJKutf8}   % for Chinese characters
\usepackage{ctex}
\usepackage{enumerate}
\usepackage{graphicx}  % for figures
\usepackage{layout}
\usepackage{multicol}  % multiple columns to reduce number of pages
\usepackage{mathrsfs}  
\usepackage{fancyhdr}
\usepackage{subfigure}
\usepackage{tcolorbox}
\usepackage{tikz-cd}
\usepackage{listings}
\usepackage{xcolor} %代码高亮
%------------------
% common commands %
%------------------
% differentiation
\newcommand{\gen}[1]{\left\langle #1 \right\rangle}
\newcommand{\dif}{\mathrm{d}}
\newcommand{\difPx}[1]{\frac{\partial #1}{\partial x}}
\newcommand{\difPy}[1]{\frac{\partial #1}{\partial y}}
\newcommand{\Dim}{\mathrm{D}}
\newcommand{\avg}[1]{\left\langle #1 \right\rangle}
\newcommand{\sgn}{\mathrm{sgn}}
\newcommand{\Span}{\mathrm{span}}
\newcommand{\dom}{\mathrm{dom}}
\newcommand{\Arity}{\mathrm{arity}}
\newcommand{\Int}{\mathrm{Int}}
\newcommand{\Ext}{\mathrm{Ext}}
\newcommand{\Cl}{\mathrm{Cl}}
\newcommand{\Fr}{\mathrm{Fr}}
% group is generated by
\newcommand{\grb}[1]{\left\langle #1 \right\rangle}
% rank
\newcommand{\rank}{\mathrm{rank}}
\newcommand{\Iden}{\mathrm{Id}}

% this environment is for solutions of examples and exercises
\newenvironment{solution}%
{\noindent\textbf{Solution.}}%
{\qedhere}
% the following command is for disabling environments
%  so that their contents do not show up in the pdf.
\makeatletter
\newcommand{\voidenvironment}[1]{%
  \expandafter\providecommand\csname env@#1@save@env\endcsname{}%
  \expandafter\providecommand\csname env@#1@process\endcsname{}%
  \@ifundefined{#1}{}{\RenewEnviron{#1}{}}%
}
\makeatother

%---------------------------------------------
% commands specifically for complex analysis %
%---------------------------------------------
% complex conjugate
\newcommand{\ccg}[1]{\overline{#1}}
% the imaginary unit
\newcommand{\ii}{\mathbf{i}}
%\newcommand{\ii}{\boldsymbol{i}}
% the real part
\newcommand{\Rez}{\mathrm{Re}\,}
% the imaginary part
\newcommand{\Imz}{\mathrm{Im}\,}
% punctured complex plane
\newcommand{\pcp}{\mathbb{C}^{\bullet}}
% the principle branch of the logarithm
\newcommand{\Log}{\mathrm{Log}}
% the principle value of a nonzero complex number
\newcommand{\Arg}{\mathrm{Arg}}
\newcommand{\Null}{\mathrm{null}}
\newcommand{\Range}{\mathrm{range}}
\newcommand{\Ker}{\mathrm{ker}}
\newcommand{\Iso}{\mathrm{Iso}}
\newcommand{\Aut}{\mathrm{Aut}}
\newcommand{\ord}{\mathrm{ord}}
\newcommand{\Res}{\mathrm{Res}}
%\newcommand{\GL2R}{\mathrm{GL}(2,\mathbb{R})}
\newcommand{\GL}{\mathrm{GL}}
\newcommand{\SL}{\mathrm{SL}}
\newcommand{\Dist}[2]{\left|{#1}-{#2}\right|}



%----------------------------------------
% theorem and theorem-like environments %
%----------------------------------------
\numberwithin{equation}{chapter}
\theoremstyle{definition}

\newtheorem{thm}{Theorem}[chapter]
\newtheorem{axm}[thm]{Axiom}
\newtheorem{alg}[thm]{Algorithm}
\newtheorem{asm}[thm]{Assumption}
\newtheorem{defn}[thm]{Definition}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{rul}[thm]{Rule}
\newtheorem{coro}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{exm}{Example}[chapter]
\newtheorem{rem}{Remark}[chapter]
\newtheorem{exc}[exm]{Exercise}
\newtheorem{frm}[thm]{Formula}
\newtheorem{ntn}{Notation}

% for complying with the convention in the textbook
\newtheorem{rmk}[thm]{Remark}


%\lstset{
%	backgroundcolor=\color{red!50!green!50!blue!50},%代码块背景色为浅灰色
%	rulesepcolor= \color{gray}, %代码块边框颜色
%	breaklines=true,  %代码过长则换行
%	numbers=left, %行号在左侧显示
%	numberstyle= \small,%行号字体
%	keywordstyle= \color{blue},%关键字颜色
%	commentstyle=\color{gray}, %注释颜色
%	frame=shadowbox%用方框框住代码块
%}
\lstset{
	columns=fixed,       
	numbers=left,                                        % 在左侧显示行号
	numberstyle=\tiny\color{gray},                       % 设定行号格式
	frame=none,                                          % 不显示背景边框
	backgroundcolor=\color[RGB]{245,245,244},            % 设定背景颜色
	keywordstyle=\color[RGB]{40,40,255},                 % 设定关键字颜色
	numberstyle=\footnotesize\color{darkgray},           
	commentstyle=\it\color[RGB]{0,96,96},                % 设置代码注释的格式
	stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},   % 设置字符串格式
	showstringspaces=false,                              % 不显示字符串中的空格
	language=c++,                                        % 设置语言
}

%----------------------
% the end of preamble %
%----------------------

\begin{document}
\pagestyle{empty}
\pagenumbering{roman}

\tableofcontents
\clearpage

\pagestyle{fancy}
\fancyhead{}
\lhead{Qinghai Zhang}
\chead{Notes on Algebraic Topology}
\rhead{Fall 2018}

\setcounter{chapter}{0}
\pagenumbering{arabic}
% \setcounter{page}{0}

% --------------------------------------------------------
% uncomment the following to remove these environments 
%  to generate handouts for students.
% --------------------------------------------------------
% \begingroup
% \voidenvironment{rem}%
% \voidenvironment{proof}%
% \voidenvironment{solution}%


% each chapter is factored into a separate file.

\chapter{3D Boolean Algebra}
%\begin{lstlisting}
%int main(){
%  double d;
%  int i;
%  return i;
%}
%\end{lstlisting}
% The main ingredients of snacks are sugar and fat;
%  the main ingredients of math are logic and set theory.
I'm coming to design a c++ program for Boolean Algebra on Yin sets in $ \mathbb{R}^3 $ 

\begin{multicols}{2}
\setlength{\columnseprule}{0.2pt}  

\section{ Translating from Mathematical Concepts to Classes}

\subsection{Point to Class Point}
Properties:
\begin{itemize}
	\item[1] Coordinates in $ \mathbb{R}^3  \\ \longrightarrow $ double coord[3] 
	
	\item[2] Identity \\
	$ \longrightarrow $ int id
	
	\item[3] Contained by some segments \\
	$ \longrightarrow $ vector<int> insegment
	
	\item[4] Contained by a Yin set \\
	$ \longrightarrow $ int inYinset
\end{itemize}

Operators:
\begin{itemize}
	\item[1] Return coordinates \\
	$ \longrightarrow $ double operator[](const int) 
	
	\item[2] Computing vector between two points \\
	$ \longrightarrow $ Direction operator-(const Point) 
	
	\item[3] Get a point obtained by displacement in the direction of vector \\
	$ \longrightarrow $ Point operator+(const Direction)
	
	\item[4] Determining the order relation and equivalence relation of every points \\
	$ \longrightarrow $ 
	bool operator==(const Point) \\
	bool operator<(const Point) \\
	bool operaotr>(const Point) 
\end{itemize}


\subsection{Vector to Class Direction}

Property:
\begin{itemize}
	\item Represent a Vector \\
	$ \longrightarrow $ double coord[3]
\end{itemize}

Operator:
\begin{itemize}
	\item[1] Plus and Minus between vectors \\
	$ \longrightarrow $ Direction operator+-(const Direction)
	
	\item[2] Quantitative Product of vector \\
	$ \longrightarrow $ Direction operator*/(const double) 
	
	\item[3] Dot Product of vector \\ 
	$ \longrightarrow $ double dot(const Direction)
	
	\item[4] Cross Product of vector \\
	$ \longrightarrow $ Direction cross(const Direction)
	
	\item[5] Modulus operation \\
	$ \longrightarrow $ double norm() 
	
	\item[6] Unitization operation \\ $ \longrightarrow $ Direction unit()
 
\end{itemize}

\subsection{Straight Line to Class Line}
Property:
\begin{itemize}
	\item A point in this line \\
	$ \longrightarrow $ Point fixpoint 
	
	\item Direction of the line \\
	$ \longrightarrow $ Direction direct
	
\end{itemize}

Operator:
\begin{itemize}
	\item Determining whether two straight lines intersect \\
	$ \longrightarrow $ bool ifintersectionLine(const Line)
	
	\item Calculating the intersection of two lines \\
	$ \longrightarrow $ Point intersectionLine(const Line)
	
	\item Determining whether contain a point \\
	$ \longrightarrow $ bool ifcontainPoint(const Point)
	
\end{itemize}

\subsection{Plane to Class Flat}

Property:
\begin{itemize}
	\item A point is contained by the plane \\
	$ \longrightarrow $ Point fixpoint 
	
	\item A normal vector of the plane \\
	$ \longrightarrow $ Direction normaldirect
	
\end{itemize}

Operator:
\begin{itemize}
	\item Used to calculate intersection between Planes \\
	$ \longrightarrow $ bool ifintersectionFlat(const Flat)
	\\ Line intersectionFlat(const Flat)
	
	\item Calculate intersection of a straight line and the plane \\
	$ \longrightarrow $ bool ifintersectionLine(const Line) \\ Point intersectionLine(const Line)
	
	\item Determining if contain a point and a segment . \\
	$ \longrightarrow $ bool ifcontainPoint(const Point)
	\\ bool ifcontainSegment(const Segment)
	

\end{itemize}


\subsection{Segment to Class Segment : Public Line}

Property:
\begin{itemize}
	\item[1] Each one in Class Line. 
	
	\item[2] Identities of endpoints of Segment.\\
	$ \longrightarrow $ vector<int> points
	
	\item[3] Identity . \\
	$ \longrightarrow $ int id
	
	\item[4] Identities of Planars that contains the Segment. \\
	$ \longrightarrow $ vector<int> inPlanar 
	
	\item[5] Identity of a Yinset that contains it. \\
	$ \longrightarrow $ int inYinset  
\end{itemize}

Operator:
\begin{itemize}
	\item[1] Every operator in Class Line.
	
	\item[2] Return endpoints. \\
	 $ \longrightarrow $ Point operator[](const int)
	 
	\item[3] Determining equality.\\
	$ \longrightarrow $ bool operator==(const Segment)
	
	\item[4] Determining and Calculating intersection of two Segments.\\
	$ \longrightarrow $ bool ifintersectionSegment(const Segment) \\
	Point intersectionSegment(const Segment) 
	
	\item[5] Determining whether contains a Point. \\
	$ \longrightarrow $ bool
	ifcontainPoint(const Point)
	  
\end{itemize}


%\label{sec:logic}
%\input{sec/logic.tex}

\section{UML Class Diagram}
%\label{sec:sets}
%\input{sec/orderedSets.tex}

\section{Algorithm Implementation}
%\label{sec:line-algebra}
%\input{sec/linearAlgebra.tex}
\subsection{Class Point}


\subsubsection{Point::operator[](const int)}
\paragraph{契约}
\subparagraph{input}
const int
\subparagraph{output}
X,Y,Z-coordinate respectively
\subparagraph{precondition}
0, 1, 2
\subparagraph{postcondition}
double
\paragraph{算法实现}
\begin{lstlisting}
return directly
\end{lstlisting}
\paragraph{证明}


\subsubsection{Point::operator-+()}
\paragraph{契约}
\subparagraph{input}
Two Points (a Point and a Direction)
\subparagraph{output}
A Direction (Point)
\subparagraph{precondition}
non
\subparagraph{postcondition}
Match the relationship between two points and the vector between them.

\paragraph{算法实现}
\begin{lstlisting}
for i : 0-2
lhs.coord[i] -(+) rhs.coord[i]
\end{lstlisting}
\paragraph{证明}

\subsubsection{Point::operator==><(const Point)}
\paragraph{契约}
\subparagraph{input}
Two Points and double Tol::t
\subparagraph{output}
Bool value
\subparagraph{precondition}
Two Point p1, p2.
\subparagraph{postcondition}
Satisfy the dictionary order relation of points with the tolerance's value equal Tol::t.
\paragraph{算法实现}
\begin{lstlisting}
operator<():
if(coord[2] < q.coord[2] - Tol::t)
	return true;
else if((coord[2] < q.coord[2] + Tol::t)
&& (coord[1] < q.coord[1] - Tol::t))
	return true;
else if((coord[2] < q.coord[2] + Tol::t) &&
(coord[1] < q.coord[1] + Tol::t) &&
(coord[0] < q.coord[0] - Tol::t))
	return true;
else
	return false;

\end{lstlisting}
\paragraph{证明}

\subsection{Class Direction}

Accomplishing vector's +-,Quantitative Product, Dot Product and Cross Product.


\subsection{Class Line}
\subsubsection{Line::ifcontainPoint(const Point)}
\paragraph{契约}
\subparagraph{input}
A Line l and A Point p , Tol::t
\subparagraph{output}
Bool value
\subparagraph{precondition}
non
\subparagraph{postcondition}
set the smallest distance d from p to l ,return d < Tol::t.
\paragraph{算法实现}
\begin{lstlisting}
Direction d1 = l.drect.unit();
Direction d2 = p - l.fixpoint;
double d = d1.cross(d2).norm();
return d < Tol::t
\end{lstlisting}
\paragraph{证明}
|d1| = 1 and $ \theta $ is the angle between d1 and d2\\
d1.cross(d2) = |d1| * |d2| * sin$ \theta $ \\
= |d2| * sin$ \theta $ \\
= d
\subsubsection{Line::(if)intersectionLine(const Line)}
\paragraph{契约}
\subparagraph{input}
Two Lines l1, l2, Tol:t
\subparagraph{output}
Bool or the intersection
\subparagraph{precondition}
Take intersectionLine() if and only if ifintersectionLine() return true.
\subparagraph{postcondition}
return false when l1 parallel with l2 or return the intersection of l1 and l2.
\paragraph{算法实现}
\begin{lstlisting}
Direction d1 = l1.drect, d2 = l2.drect;
Direction d3 = d1.cross(d2).unit();
ifintersectionLine() : 
return 
fabs(d3.dot(l1.fixpoint - l2.fixpoint)) 
< Tol::t;

Direction d4 = d1.cross(d3);
Flat f(l1.fixpoint, d4);
intersectionLine() : 
return f.intersectionLine(l2);

\end{lstlisting}
\paragraph{证明}
d3 $ \bot $ d1 and d3 $ \bot $ d2. And |d3.unit()| = 1\\

So d3 dot product with l1.fixpoint - l2.fixpoint value is the smallest distance between l1 and l2. \\

The smallest distance vector d0 must be perpendicular to d1 and d2. \\

So d0 has same direct with d3.
and d0 must intersect with l1,get d0 in the plane f. \\

d0 must intersect with l2, then d0 contain the point p get from f intersect l2. \\

Choose p as intersection of l1 and l2. return.


\subsection{Class Flat}

\subsubsection{Flat::(if)intersectionLine()}
\paragraph{契约}
\subparagraph{input}
A Flat f and A Line l, Tol::t
\subparagraph{output}
Bool or intersection.
\subparagraph{precondition}
Take intersectionLine() if and only if ifintersectionLine() return true.
\subparagraph{postcondition}
While parallel return false , or return true and the intersection point.
\paragraph{算法实现}
\begin{lstlisting}
Direction d1 = f.normaldirect,
          d2 = l.direct;
ifintersectionLine() : 
return fabs(d1.dot(d2)) > Tol::t;

calculate intersection is 
"using Cramer's Rule to 
solve ternary equations."


\end{lstlisting}
\paragraph{证明}
Dot Product can be used to detect if parallel.


\subsubsection{Flat::(if)intersectionFlat(const Flat)}
\paragraph{契约}
\subparagraph{input}
Two Flat f1, f2. Tol::t
\subparagraph{output}
False or true and a Line. 
\subparagraph{precondition}
Take intersectionFlat() if and only if ifintersectionFlat() return true.
\subparagraph{postcondition}
While parallel return false , or return true and the intersection Line.
\paragraph{算法实现}
\begin{lstlisting}
Direction d1 = f1.normaldirect,
		  d2 = f2.normaldirect;
Direction d3 = d1.cross(d2).unit(); 
ifintersectionFlat() :
return d1.cross(d2).norm() < Tol::t

"assumpting d3[0] > d3[1] and 
d3[0] > d3[2].
add a equation x = 1,
using Cramer's Rule to 
solve ternary equations."

\end{lstlisting}
\paragraph{证明}

\subsubsection{Flat::ifcontainPoint(Segment)()}
\paragraph{契约}
\subparagraph{input}
A Point p or A Segment seg. Tol::t
\subparagraph{output}
Bool value
\subparagraph{precondition}
non
\subparagraph{postcondition}
If the Plane contain Point or Segment return true, else return false.
\paragraph{算法实现}
\begin{lstlisting}
Direction d = p - fixpoint;
double d = fabs(d.dot(normaldirect));
ifcontainPoint() :
return d < Tol::t

ifcontainSegment() : 
return ifcontainPoint(seg[0]) && 
	ifcontainPoint(seg[1]);
\end{lstlisting}
\paragraph{证明}


\subsection{Class Segment : Public Line }

\subsubsection{Segment::operator[](const int)}
\paragraph{契约}
\subparagraph{input}
int
\subparagraph{output}
A Point
\subparagraph{precondition}
0 ,1
\subparagraph{postcondition}
When input 0, return the smaller point, 1 return  the other point. 
\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{Segment::operator==(const Segment)}
\paragraph{契约}
\subparagraph{input}
Two Segment seg1, seg2. Tol::t.
\subparagraph{output}
Bool value.
\subparagraph{precondition}
non
\subparagraph{postcondition}
While Segments' endpoints equal respectively, returning true. Otherwise return false.
\paragraph{算法实现}
\begin{lstlisting}
return seg1[0] == seg2[0] && seg1[1] == seg2[1];
\end{lstlisting}
\paragraph{证明}

\subsubsection{Segment::(if)intersectionSegment(const Segment)}
\paragraph{契约}
\subparagraph{input}
Two segment seg1, seg2. Tol::t.
\subparagraph{output}
...
\subparagraph{precondition}
Seg1 don't contain seg2's endpoints, seg2 too.
\subparagraph{postcondition}
...
\paragraph{算法实现}
\begin{lstlisting}
if(!seg1.ifintersectionLine(seg2))
	ifintersectionSegment() : 
	return false;
Point p seg1.intersectionLine(seg2);
if(!(p > seg1[0] && p < seg1[1] &&
     p > seg2[0] && p < seg2[1]) )
   	ifintersectionSegment() :
   	return false;
ifintersectionSegment() :
   	return true;
intersettionSegment() :
	return p;
\end{lstlisting}
\paragraph{证明}

\subsubsection{Segment::ifcontainPoint(const Point)}
\paragraph{契约}
\subparagraph{input}
A Segment seg and a Point p. Tol::t
\subparagraph{output}
...
\subparagraph{precondition}
non
\subparagraph{postcondition}
...
\paragraph{算法实现}
\begin{lstlisting}
if(!Line::ifcontainPoint(p)) 
	return false;
double d1 = 
(p - seg[0]).dot(seg[1] - seg[0]),
d2 = 
(seg[1] - seg[0]).dot(seg[1] - seg[0]));
if(d1 < 0 || d1 > d2)
	return false;
return true;	
\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}



\end{multicols}


\end{document}




\subsubsection{}
\paragraph{契约}
\subparagraph{input}

\subparagraph{output}

\subparagraph{precondition}

\subparagraph{postcondition}

\paragraph{算法实现}
\begin{lstlisting}

\end{lstlisting}
\paragraph{证明}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

% LocalWords:  FPN underflows denormalized FPNs matlab eps IEEE iff
% LocalWords:  cardinality significand quadratically bijection unary
%  LocalWords:  contractive bijective postcondition invertible arity
%  LocalWords:  subspaces surjective injective monomials additivity
%  LocalWords:  nullary Abelian abelian finitary eigenvectors adjoint
%  LocalWords:  eigenvector nullspace Hermitian unitarily multiset
%  LocalWords:  nonsingular nonconstant homomorphism homomorphisms
%  LocalWords:  isomorphically indeterminates subfield isomorphism
%  LocalWords:  nondefective diagonalizable contrapositive cofactor
%  LocalWords:  submatrix nilpotent positivity orthonormal extremum
%  LocalWords:  Jacobian nonsquare semidefinite nonnegative RHS LLS
%  LocalWords:  roundoff closedness
